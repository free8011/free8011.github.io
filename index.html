<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>나만의 축구 스쿼드</title>
    <!-- html2canvas 라이브러리: 캔버스 내용을 이미지로 저장하는 데 사용됩니다. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* 기본 스타일 및 폰트 설정 */
        body {
            font-family: 'Inter', sans-serif; /* Inter 폰트 사용 */
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0; /* 밝은 회색 배경 */
            min-height: 100vh; /* 뷰포트 전체 높이 사용 */
            width: 100%;
        }

        /* 제목 스타일 */
        h1 {
            color: #333;
            margin-top: 20px;
            font-size: 2.5rem; /* 큰 제목 */
        }

        /* 전체 컨텐츠 컨테이너 스타일 */
        .content-container {
            display: flex;
            gap: 20px;
            width: 95%;
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        /* 왼쪽 스쿼드 편집 영역 */
        .squad-editor {
            flex: 1;
            min-width: 0; /* flexbox 오버플로우 방지 */
        }

        /* 오른쪽 스쿼드 요약 영역 */
        #squadSummary {
            width: 400px; /* 고정 너비 */
            margin-top: 0; /* 기존 마진 제거 */
            height: fit-content; /* 내용에 맞춰 높이 조정 */
            position: sticky;
            top: 20px; /* 스크롤 시 상단에 고정 */
        }

        /* 반응형 디자인을 위한 미디어 쿼리 */
        @media (max-width: 1200px) {
            .content-container {
                width: 100%;
                flex-direction: column; /* 화면이 좁아지면 세로로 배치 */
            }

            #squadSummary {
                 width: 100%; /* 전체 너비 사용 */
                position: static; /* 고정 위치 해제 */
            }
        }

        /* 컨트롤 버튼 및 셀렉트 박스 컨테이너 */
        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap; /* 작은 화면에서 요소들이 줄바꿈되도록 허용 */
            justify-content: center; /* 컨트롤 요소를 중앙 정렬 */
            align-items: center;
            gap: 15px; /* 요소 간 간격 */
            padding: 10px;
        }

        /* 컨트롤 라벨 스타일 */
        .controls label {
            font-weight: bold;
            color: #555;
            font-size: 1.1rem;
        }

        /* 컨트롤 셀렉트 박스 및 버튼 스타일 */
        .controls select, .controls button {
            padding: 10px 15px; /* 패딩 증가 */
            border: 1px solid #ccc;
            border-radius: 8px; /* 더 둥근 모서리 */
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease; /* 부드러운 전환 효과 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* 은은한 그림자 */
        }

        /* 컨트롤 버튼 기본 스타일 */
        .controls button {
            background-color: #4CAF50; /* 초록색 배경 */
            color: white;
            border: none;
            font-weight: bold;
            text-transform: uppercase; /* 대문자 텍스트 */
        }

        /* 컨트롤 버튼 호버 효과 */
        .controls button:hover {
            background-color: #45a049; /* 어두운 초록색 */
            transform: translateY(-2px); /* 살짝 위로 뜨는 효과 */
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        /* 다운로드 버튼 특정 스타일 */
        #downloadButton {
            background-color: #42b72a;
        }
        
        #downloadButton:hover {
            background-color: #36a420;
        }

        /* 스쿼드 저장 버튼 스타일 */
        #saveSquadButton {
            background-color: #007bff; /* 파란색 */
        }
        #saveSquadButton:hover {
            background-color: #0056b3;
        }


        /* 캔버스 컨테이너 (반응형) */
        #canvasContainer {
            position: relative;
            width: 100%; /* 부모 너비에 맞춤 */
            max-width: 1200px; /* 최대 너비 1200px */
            aspect-ratio: 1200 / 750; /* 캔버스 비율 유지 (가로:세로 = 1200:750) */
            border: 4px solid #333; /* 두꺼운 테두리 */
            border-radius: 15px; /* 둥근 모서리 */
            overflow: hidden; /* 내용이 컨테이너 밖으로 나가지 않도록 숨김 */
            box-shadow: 0 8px 16px rgba(0,0,0,0.3); /* 강한 그림자 */
            margin-bottom: 20px; /* 캔버스 아래 여백 */
             min-height: 300px; /* 최소 높이 설정 */
            background-color: #0f8017; /* 캔버스가 로드되기 전에도 배경색 표시 */
        }

        /* 스쿼드 캔버스 스타일 */
        #squadCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* 컨테이너에 맞춰 너비 100% */
            height: 100%; /* 컨테이너에 맞춰 높이 100% */
            display: block; /* 블록 요소로 설정 */
        }

        /* 선수 이름 입력 필드 스타일 */
        .player-input {
            position: absolute;
            background-color: rgba(8, 49, 11, 0.97); /* 어두운 초록색 배경, 반투명 */
            border: 2px solid #ccc; /* 두꺼운 테두리 */
            padding: 15px; /* 패딩 증가 */
            border-radius: 15px; /* 더 둥근 모서리 */
            box-shadow: 3px 3px 8px rgba(0,0,0,0.3); /* 강한 그림자 */
            font-weight: bold;
            cursor: grab; /* 드래그 가능한 커서 */
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10; /* 캔버스 위에 표시 */
            min-width: 150px; /* 최소 너비 */
            transition: all 0.3s ease;
        }

        /* 심판 및 촬영 인원 박스를 가로 정렬로 변경 */
        .fixed-personnel-box {
            position: absolute;
            /* 초기 위치는 JS에서 계산되므로 top/right/left는 CSS에서 제거 */
            background-color: #A34A2A; /* 붉은 계통 배경색 */
            display: flex; /* 내부 요소들을 가로로 정렬 */
            flex-wrap: wrap; /* 작은 화면에서 줄바꿈 허용 */
            justify-content: center; /* 요소들 중앙 정렬 */
            gap: 15px; /* 심판과 촬영 요소 사이 간격 */
            padding: 15px;
            border-radius: 15px;
            box-shadow: 3px 3px 8px rgba(0,0,0,0.3);
            z-index: 10;
            cursor: grab; /* 드래그 가능한 커서 */
            transition: all 0.3s ease; /* 드래그 및 위치 변경 시 부드러운 전환 */
        }

        .fixed-personnel-box:active {
            cursor: grabbing; /* 드래그 중인 커서 */
            transform: scale(1.02); /* 살짝 커지는 효과 */
        }


        .fixed-personnel-item {
            display: flex;
            flex-direction: column; /* 각 역할의 레이블과 선택 박스를 세로로 정렬 */
            align-items: center;
            gap: 5px; /* 레이블과 선택 박스 사이 간격 */
        }

        /* 선수 이름 입력 필드 활성화 시 효과 */
        .player-input:active {
            cursor: grabbing; /* 드래그 중인 커서 */
            transform: scale(1.02); /* 살짝 커지는 효과 */
        }

        /* 선수 라벨 스타일 */
        .player-input label, .fixed-personnel-item label {
            font-size: 1.1em; /* 약간 큰 폰트 */
            color: #ffffff; /* 흰색 글자 */
            margin-bottom: 6px; /* 아래 여백 증가 (player-input에는 적용, fixed-personnel-item에서는 덮어씌워짐) */
        }
        .fixed-personnel-item label {
            margin-bottom: 0; /* fixed-personnel-item 내에서는 마진 0 */
            white-space: nowrap; /* 텍스트 줄바꿈 방지 */
        }


        /* 선수 이름 드롭다운 (select) 스타일 */
        .player-input .player-name-select, .fixed-personnel-item .player-name-select {
            width: calc(100% - 10px); /* 패딩을 고려하여 너비 조정 */
            height: 35px; /* 높이 증가 */
            padding: 5px; /* 패딩 조정 */
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            font-size: 1.1rem; /* 약간 큰 폰트 */
            color: #333; /* 어두운 글자색 */
            background-color: #f9f9f9; /* 밝은 배경색 */
            -webkit-appearance: none; /* 기본 드롭다운 화살표 제거 */
            -moz-appearance: none;
            appearance: none;
            /* 커스텀 드롭다운 화살표 SVG 아이콘 */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M287%2C114.7L159.2%2C242.5c-2.3%2C2.3-5.5%2C3.6-8.8%2C3.6s-6.5-1.3-8.8-3.6L5.3%2C114.7c-4.7-4.7-4.7-12.3%2C0-17s12.3-4.7%2C17%2C0l137.9%2C137.9c0.8%2C0.8%2C1.8%2C1.2%2C2.8%2C1.2s2-0.4%2C2.8-1.2l137.9-137.9c4.7-4.7%2C12.3-4.7%2C17%2C0S291.6%2C110%2C287%2C114.7z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            padding-right: 30px; /* 커스텀 화살표를 위한 공간 */
        }
        .fixed-personnel-item .player-name-select {
            width: 100px; /* 고정 인원 셀렉트 박스 너비 조정 */
        }

        /* 선수 명단 관리 섹션 스타일 */
        .player-roster-management {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #e0e0e0;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .player-roster-management label {
            flex-basis: 100%; /* 작은 화면에서 라벨이 한 줄 전체 차지 */
            text-align: center;
            margin-bottom: 5px;
            color: #333;
        }

        .player-roster-management input[type="text"] {
            flex-grow: 1; /* 남은 공간을 채우도록 성장 */
            padding: 8px 12px;
            border: 1px solid #bbb;
            border-radius: 5px;
            font-size: 1rem;
        }

        .player-roster-management button {
            background-color: #007bff; /* 파란색 버튼 */
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .player-roster-management button:hover {
            background-color: #0056b3;
        }


        /* 사용자 정의 확인 모달 오버레이 */
        .modal-overlay {
            position: fixed; /* 뷰포트에 고정 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* 반투명 검정 배경 */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* 최상위 레이어 */
            visibility: hidden; /* 기본적으로 숨김 */
            opacity: 0; /* 기본 투명도 0 */
            transition: opacity 0.3s ease, visibility 0.3s ease; /* 부드러운 나타나기/사라지기 효과 */
        }

        /* 모달이 보일 때 스타일 */
        .modal-overlay.visible {
            visibility: visible;
            opacity: 1;
        }

        /* 모달 콘텐츠 박스 */
        .modal-content {
            background-color: #fff; /* 흰색 배경 */
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* 그림자 */
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px); /* 초기 위치 (아래로 살짝 내려와서 나타남) */
            transition: transform 0.3s ease;
        }

        /* 모달이 보일 때 콘텐츠 위치 */
        .modal-overlay.visible .modal-content {
            transform: translateY(0); /* 원래 위치로 이동 */
        }

        /* 모달 메시지 텍스트 */
        .modal-content p {
            margin-bottom: 25px;
            font-size: 1.2rem;
            color: #333;
            font-weight: bold;
        }

        /* 모달 버튼 컨테이너 */
        .modal-buttons button {
            margin: 0 10px;
            padding: 12px 25px;
            border: none;
            border-radius: 6px;
            font-size: 1.1rem;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        /* 모달 확인 버튼 */
        .modal-buttons button.confirm {
            background-color: #dc3545; /* 빨간색 (위험한 작업) */
            color: white;
        }

        .modal-buttons button.confirm:hover {
            background-color: #c82333;
        }

        /* 모달 취소 버튼 */
        .modal-buttons button.cancel {
            background-color: #6c757d; /* 회색 (취소) */
            color: white;
        }

        .modal-buttons button.cancel:hover {
            background-color: #5a6268;
        }

        /* 스쿼드 요약 테이블 스타일 */
        #squadSummary {
            padding: 20px;
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
        }

        #squadSummary h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        #squadSummary table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        #squadSummary th, #squadSummary td {
            border: 1px solid #ddd;
            padding: 12px 10px;
            text-align: left;
        }

        #squadSummary th {
            background-color: #f2f2f2;
            font-weight: bold;
            color: #555;
            text-align: center;
            cursor: pointer; /* Make headers clickable for sorting */
        }

        #squadSummary th:hover {
            background-color: #e6e6e6; /* Hover effect for sortable headers */
        }

        #squadSummary td {
            text-align: center;
            color: #333;
        }

        #squadSummary tbody tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #squadSummary tbody tr:hover {
            background-color: #e6f7ff; /* 호버 시 배경색 변경 */
        }
        /* 삭제 버튼 스타일 */
        .delete-button {
            background-color: #dc3545; /* 빨간색 */
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }
        .delete-button:hover {
            background-color: #c82333;
        }
    </style>
</head>
<body>
    <h1>나만의 축구 스쿼드</h1>
    <div class="content-container">
        <!-- 왼쪽 섹션: 스쿼드 편집 영역 -->
        <div class="squad-editor">
            <div class="controls">
                <label for="formationSelect">전술 선택:</label>
                <select id="formationSelect">
                    <option value="4-2-3-1">4-2-3-1</option>
                    <option value="4-1-2-3">4-1-2-3</option>
                    <option value="4-3-3">4-3-3</option>
                    <option value="4-4-2">4-4-2</option>
                    <option value="3-5-2">3-5-2</option>
                    <option value="5-3-2">5-3-2</option>
                    <!-- 필요한 경우 다른 전술 옵션 추가 -->
                </select>
                <select id="quarterSelect">
                    <option value="1 쿼터">1 쿼터</option>
                    <option value="2 쿼터">2 쿼터</option>
                    <option value="3 쿼터">3 쿼터</option>
                    <option value="4 쿼터">4 쿼터</option>
                </select>
                <button id="saveSquadButton">스쿼드 저장</button> <!-- 스쿼드 저장 버튼 -->
                <button id="downloadButton">PNG로 저장</button> <!-- PNG 다운로드 버튼 -->
            </div>
            <br>
            <!-- 캔버스 및 선수 이름 입력 필드 컨테이너 -->
            <div id="canvasContainer">
                <canvas id="squadCanvas"></canvas> <!-- 캔버스 크기는 JavaScript로 설정됩니다. -->
                <!-- Player-input 요소들은 이 컨테이너 안에 동적으로 추가됩니다. -->

                <!-- 심판 및 촬영 인원 통합 박스 -->
                <div id="fixedPersonnelBox" class="fixed-personnel-box">
                    <div class="fixed-personnel-item">
                        <label>심판</label>
                        <select id="refereeSelect" class="player-name-select"></select>
                    </div>
                    <div class="fixed-personnel-item">
                        <label>촬영</label>
                        <select id="filmingSelect" class="player-name-select"></select>
                    </div>
                </div>
            </div>

        </div>
        <!-- Squad Summary Section -->
        <div id="squadSummary">
            <div class="controls">
                <!-- 새로운 선수 명단 추가 섹션 -->
                <div class="player-roster-management">
                    <label for="newPlayerNameInput">새 선수 명단 추가 (쉼표 또는 띄어쓰기로 구분):</label>
                    <input type="text" id="newPlayerNameInput" placeholder="예: 김철수, 이영희, 박지성">
                    <button id="addPlayerToRosterButton">명단에 추가</button>
                </div>
            </div>
            <h2>스쿼드 요약</h2>
            <table>
                <thead>
                    <tr>
                        <th data-sort-key="name">선수 이름</th>
                        <th data-sort-key="quarters">포함된 쿼터</th>
                        <th data-sort-key="quarterCount">포함된 쿼터 수</th>
                        <th>작업</th> <!-- 새로운 열 추가 -->
                    </tr>
                </thead>
                <tbody id="squadSummaryBody">
                <!-- 데이터는 JavaScript로 여기에 삽입됩니다 -->
                </tbody>
            </table>
        </div>
    </div>
</div>

<script>
        // DOM 요소 가져오기
        const canvas = document.getElementById('squadCanvas');
        const ctx = canvas.getContext('2d');
        const formationSelect = document.getElementById('formationSelect');
        const downloadButton = document.getElementById('downloadButton');
        const canvasContainer = document.getElementById('canvasContainer');
        const quarterSelect = document.getElementById('quarterSelect');

        // 새롭게 추가된 선수 명단 관리 요소들
        const newPlayerNameInput = document.getElementById('newPlayerNameInput');
        const addPlayerToRosterButton = document.getElementById('addPlayerToRosterButton');
        const saveSquadButton = document.getElementById('saveSquadButton'); // 스쿼드 저장 버튼
        const squadSummaryBody = document.getElementById('squadSummaryBody'); // 요약 테이블 본문
        const squadSummaryTable = document.querySelector('#squadSummary table'); // 헤더 클릭을 위한 테이블 요소

        // Fixed personnel specific elements
        const refereeSelect = document.getElementById('refereeSelect');
        const filmingSelect = document.getElementById('filmingSelect');
        const fixedPersonnelBox = document.getElementById('fixedPersonnelBox');


        // 캔버스 크기를 부모 컨테이너에 맞춰 동적으로 설정하는 함수
        function setCanvasDimensions() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;

            // 고정 인원 박스 위치를 캔버스 크기에 맞춰 계산 및 설정
            const originalCanvasWidth = 1200;
            const originalCanvasHeight = 750;

            const scaledX = (fixedPersonnelData.x / originalCanvasWidth) * canvasContainer.clientWidth;
            const scaledY = (fixedPersonnelData.y / originalCanvasHeight) * canvasContainer.clientHeight;

            fixedPersonnelBox.style.left = `${scaledX - fixedPersonnelBox.offsetWidth / 2}px`;
            fixedPersonnelBox.style.top = `${scaledY - fixedPersonnelBox.offsetHeight / 2}px`;
        }

        let players = []; // 선수 데이터 배열: { id, position, name, x, y, inputElement }
        let selectedPlayer = null; // 드래그 중인 선수를 추적하는 변수
        let offsetX, offsetY; // 드래그 시작 시 마우스와 요소 간의 오프셋

        // 쿼터별 저장된 스쿼드를 담는 객체
        // 데이터는 메모리에 저장되며, 페이지를 새로고침하면 사라집니다.
        let savedSquads = {};

        // 미리 정의된 선수 이름 목록 (초기값: '선택'만 포함)
        const playerNames = ["선택"];

        // 스쿼드 요약 테이블 정렬 상태
        let currentSortColumn = 'name'; // 기본 정렬 기준은 이름
        let currentSortDirection = 'asc'; // 기본 정렬 방향은 오름차순

        // 고정 인원 박스의 현재 위치 데이터 (원본 캔버스 기준)
        let fixedPersonnelData = {
            id: 'fixedBox', // 고유 ID
            x: 1200 * 0.85, // 우측 상단 X (중앙 기준)
            y: 750 * 0.1, // 우측 상단 Y (중앙 기준)
            element: fixedPersonnelBox // 실제 DOM 요소 참조
        };

        // 전술별 포지션 기본 위치 (원본 1200x750 캔버스 기준 비율)
        // 이 좌표는 캔버스 컨테이너 크기에 따라 자동으로 스케일링됩니다.
        const formations = {
            '4-2-3-1': { GK: { x: 0.5, y: 0.9 }, DF: [{ x: 0.12, y: 0.7 }, { x: 0.32, y: 0.75 }, { x: 0.68, y: 0.75 }, { x: 0.88, y: 0.7 }], DM: [{ x: 0.35, y: 0.55 }, { x: 0.65, y: 0.55 }], LW: { x: 0.25, y: 0.35 }, AM: { x: 0.5, y: 0.3 }, RW: { x: 0.75, y: 0.35 }, ST: { x: 0.5, y: 0.1 } },
            '4-3-3': { GK: { x: 0.5, y: 0.9 }, DF: [{ x: 0.12, y: 0.7 }, { x: 0.32, y: 0.75 }, { x: 0.68, y: 0.75 }, { x: 0.88, y: 0.7 }], CM: [{ x: 0.25, y: 0.45 }, { x: 0.5, y: 0.45 }, { x: 0.75, y: 0.45 }], LW: { x: 0.15, y: 0.25 }, ST: { x: 0.5, y: 0.15 }, RW: { x: 0.85, y: 0.25 } },
            '3-5-2': { GK: { x: 0.5, y: 0.9 }, CB: [{ x: 0.25, y: 0.7 }, { x: 0.5, y: 0.75 }, { x: 0.75, y: 0.7 }], LM: { x: 0.15, y: 0.45 }, CM: [{ x: 0.35, y: 0.55 }, { x: 0.5, y: 0.4 }, { x: 0.65, y: 0.55 }], RM: { x: 0.85, y: 0.45 }, ST: [{ x: 0.4, y: 0.2 }, { x: 0.6, y: 0.2 }] },
            '5-3-2': { GK: { x: 0.5, y: 0.93 }, CB: [{ x: 0.1, y: 0.7 }, { x: 0.3, y: 0.72 }, { x: 0.5, y: 0.75 }, { x: 0.7, y: 0.72 }, { x: 0.9, y: 0.7 }], CM: [{ x: 0.25, y: 0.45 }, { x: 0.5, y: 0.50 }, { x: 0.75, y: 0.45 }], ST: [{ x: 0.4, y: 0.2 }, { x: 0.6, y: 0.2 }] },
            '4-4-2': { GK: { x: 0.5, y: 0.9 }, DF: [{ x: 0.12, y: 0.7 }, { x: 0.32, y: 0.75 }, { x: 0.68, y: 0.75 }, { x: 0.88, y: 0.7 }], MF: [{ x: 0.15, y: 0.45 }, { x: 0.35, y: 0.5 }, { x: 0.65, y: 0.5 }, { x: 0.85, y: 0.45 }], ST: [{ x: 0.35, y: 0.2 }, { x: 0.65, y: 0.2 }] },
            '4-1-2-3': { GK: { x: 0.5, y: 0.9 }, DF: [{ x: 0.12, y: 0.7 }, { x: 0.32, y: 0.75 }, { x: 0.68, y: 0.75 }, { x: 0.88, y: 0.7 }], DM: { x: 0.5, y: 0.55 }, CM: [{ x: 0.35, y: 0.4 }, { x: 0.65, y: 0.4 }], LW: { x: 0.15, y: 0.25 }, RW: { x: 0.85, y: 0.25 }, ST: { x: 0.5, y: 0.15 } }
        };

        /**
         * 축구장 필드를 캔버스에 그리는 함수
         * @param {CanvasRenderingContext2D} targetCtx - 그림을 그릴 캔버스의 2D 컨텍스트
         * @param {string} quarterText - 표시할 쿼터 텍스트 (예: "1 쿼터")
         */
        function drawField(targetCtx, quarterText) {
            const canvasWidth = targetCtx.canvas.width;
            const canvasHeight = targetCtx.canvas.height;

            // 녹색 배경 그리기
            targetCtx.fillStyle = '#0f8017'; /* 잔디밭 색상 */
            targetCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            // 좌측 교체 선수 영역 그리기 (반투명 검은색)
            targetCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            const sidebarWidth = canvasWidth * 0.2; // 캔버스 너비의 20%
            targetCtx.fillRect(0, 0, sidebarWidth, canvasHeight);

            targetCtx.strokeStyle = 'white'; /* 라인 색상 */
            targetCtx.lineWidth = 6; /* 라인 두께 */
            targetCtx.beginPath();

            // 상단 아크 (센터 서클 일부) - 캔버스 크기에 비례하여 스케일링
            targetCtx.arc(canvasWidth / 2, 0, canvasWidth * 0.083, 0, Math.PI, false);

            // 페널티 박스 - 캔버스 크기에 비례하여 스케일링 및 중앙 정렬
            const pBoxWidth = canvasWidth * (500 / 1200);
            const pBoxHeight = canvasHeight * (200 / 750);
            const pBoxX = (canvasWidth - pBoxWidth) / 2;
            const pBoxY = canvasHeight * (550 / 750);
            targetCtx.strokeRect(pBoxX, pBoxY, pBoxWidth, pBoxHeight);

            // 골 에어리어
            const gBoxWidth = 220;
            const gBoxHeight = 80;

            const scaledGBoxWidth = canvasWidth * (gBoxWidth / 1200);
            const scaledGBoxHeight = canvasHeight * (gBoxHeight / 750);
            const scaledGBoxX = (canvasWidth - scaledGBoxWidth) / 2; // 중앙 정렬
            const scaledGBoxY = canvasHeight - scaledGBoxHeight; // 캔버스 하단에 위치

            targetCtx.strokeRect(scaledGBoxX, scaledGBoxY, scaledGBoxWidth, scaledGBoxHeight);

            // 페널티 아크
            const pArcRadius = canvasWidth * (70 / 1200);
            targetCtx.moveTo(canvasWidth / 2 + pArcRadius, pBoxY); // 아크 시작점으로 이동
            targetCtx.arc(canvasWidth / 2, pBoxY, pArcRadius, 0, Math.PI, true);

            targetCtx.stroke(); /* 경로 그리기 */

            // 쿼터 텍스트 그리기
            if (quarterText) {
                targetCtx.fillStyle = 'rgba(255, 255, 255, 0.9)'; /* 흰색, 반투명 */
                targetCtx.font = `bold ${canvasHeight * 0.04}px Arial`; /* 폰트 크기 캔버스 높이에 비례하여 스케일링 */
                targetCtx.textAlign = 'left';
                targetCtx.textBaseline = 'top';
                targetCtx.fillText(quarterText, canvasWidth * 0.016, canvasHeight * 0.026); /* 위치도 캔버스 크기에 비례 */
            }
        }

        // 캔버스 배경 (축구장 필드)을 다시 그리는 메인 함수
        function drawBackground() {
            setCanvasDimensions(); // 캔버스 크기 업데이트
            const selectedQuarter = quarterSelect.value;
            drawField(ctx, selectedQuarter);
        }

        /**
         * 캔버스에 표시될 모든 선택된 이름 목록을 가져오는 헬퍼 함수입니다.
         * (자기 자신은 제외하고, 다른 드롭다운에서 선택된 이름을 확인하기 위함)
         * @param {number|string|null} excludeId - 현재 이름이 선택되고 있는 요소의 ID (플레이어 ID 또는 'refereeSelect'/'filmingSelect' 문자열)
         * @returns {string[]} 현재 캔버스에서 사용 중인 이름 목록
         */
        function getAllSelectedNamesOnCanvas(excludeId = null) {
            const usedNames = new Set();

            // 필드 플레이어의 이름 추가
            players.filter(p => p.id !== excludeId && p.name !== "선택")
                   .forEach(p => usedNames.add(p.name));

            // 심판 및 촬영 인원의 이름 추가 (excludeId에 따라 현재 드롭다운 제외)
            if (refereeSelect.value !== "선택" && excludeId !== 'refereeSelect') usedNames.add(refereeSelect.value);
            if (filmingSelect.value !== "선택" && excludeId !== 'filmingSelect') usedNames.add(filmingSelect.value);

            return Array.from(usedNames);
        }

        /**
         * 선수 이름 입력 필드 (DIV 요소)를 생성하고 컨테이너에 추가하는 함수
         * @param {object} player - 선수 데이터 객체 { id, position, name, x, y }
         */
        function createPlayerInput(player) {
            const playerDiv = document.createElement('div');
            playerDiv.className = 'player-input';
            playerDiv.id = `player-${player.id}`;

            const label = document.createElement('label');
            label.textContent = player.position;
            playerDiv.appendChild(label);

            const select = document.createElement('select');
            select.className = 'player-name-select';

            const defaultOption = document.createElement('option');
            defaultOption.value = "선택";
            defaultOption.textContent = "선택";
            select.appendChild(defaultOption);

            // 드롭다운 옵션 생성 시 현재 캔버스에 사용되지 않는 이름만 포함
            const selectedNamesOnCanvas = getAllSelectedNamesOnCanvas(player.id);
            playerNames
                .filter(n => n !== "선택")
                .sort((a, b) => a.localeCompare(b))
                .forEach(playerName => {
                    if (!selectedNamesOnCanvas.includes(playerName) || playerName === player.name) {
                        const option = document.createElement('option');
                        option.value = playerName;
                        option.textContent = playerName;
                        select.appendChild(option);
                    }
                });

            select.value = player.name || "선택";

            select.addEventListener('change', (e) => {
                player.name = e.target.value;
                renderPlayers(); // 이름 변경 후 필드 플레이어 드롭다운 목록 갱신
                populateFixedPersonnelSelects(); // 고정 인원 드롭다운도 갱신
                updateSquadSummaryTable();
            });
            playerDiv.appendChild(select);

            canvasContainer.appendChild(playerDiv);

            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;
            const originalCanvasWidth = 1200;
            const originalCanvasHeight = 750;

            const scaledX = (player.x / originalCanvasWidth) * containerWidth;
            const scaledY = (player.y / originalCanvasHeight) * containerHeight;

            playerDiv.style.left = `${scaledX - playerDiv.offsetWidth / 2}px`;
            playerDiv.style.top = `${scaledY - playerDiv.offsetHeight / 2}px`;

            // player 객체에 HTML 요소 참조를 저장
            player.inputElement = playerDiv;

            playerDiv.addEventListener('mousedown', (e) => {
                // 드롭다운 클릭 시에는 드래그 방지
                if (e.target.tagName === 'SELECT') {
                    return;
                }
                selectedPlayer = player;
                offsetX = e.clientX - playerDiv.getBoundingClientRect().left;
                offsetY = e.clientY - playerDiv.getBoundingClientRect().top;
                playerDiv.style.cursor = 'grabbing';
                e.preventDefault();
            });

            return playerDiv;
        }

        // 모든 선수 이름 입력 필드를 다시 렌더링하는 함수
        function renderPlayers() {
            // 필드 플레이어만 제거 및 렌더링 (고정 인원 박스는 HTML에 고정되어 있으므로 건드리지 않음)
            canvasContainer.querySelectorAll('.player-input').forEach(el => {
                if (el.id !== 'fixedPersonnelBox') { // 고정 박스 제외
                    el.remove();
                }
            });
            // players 배열에서 심판/촬영 인원을 제외한 필드 플레이어만 렌더링
            players.filter(p => p.position !== '심판' && p.position !== '촬영').forEach(player => {
                createPlayerInput(player);
            });
        }

        /**
         * 선택된 전술에 따라 선수들을 재배치하는 함수
         * 이 함수는 이제 players 배열을 직접 수정하는 대신, 해당 전술의 플레이어 목록만 반환합니다.
         * @param {string} formation - 선택된 전술 문자열 (예: "4-2-3-1")
         * @returns {Array} 해당 전술의 기본 플레이어 목록
         */
        function getFormationPlayers(formation) {
            const formationPlayers = [];
            const currentFormation = formations[formation];
            let idCounter = 0;

            const originalCanvasWidth = 1200;
            const originalCanvasHeight = 750;

            for (const positionType in currentFormation) {
                const positions = currentFormation[positionType];
                if (Array.isArray(positions)) {
                    positions.forEach((pos) => {
                        formationPlayers.push({ id: idCounter++, position: `${positionType}`, name: '선택', x: pos.x * originalCanvasWidth, y: pos.y * originalCanvasHeight, inputElement: null });
                    });
                } else {
                    formationPlayers.push({ id: idCounter++, position: positionType, name: '선택', x: positions.x * originalCanvasWidth, y: positions.y * originalCanvasHeight, inputElement: null });
                }
            }
            return formationPlayers;
        }

        /**
         * 심판과 촬영 인원 드롭다운 옵션을 업데이트하고 선택된 값을 설정하는 함수
         */
        function populateFixedPersonnelSelects() {
            [
                { select: refereeSelect, id: 'refereeSelect' },
                { select: filmingSelect, id: 'filmingSelect' }
            ].forEach(({ select: selectElement, id: elementId }) => {
                const currentName = selectElement.value;
                selectElement.innerHTML = ''; // Clear existing options
                selectElement.appendChild(new Option("선택", "선택"));

                // 현재 선택된 이름이 다른 고정 인원이나 필드 플레이어에 의해 사용되는지 확인
                const selectedNamesOnCanvas = getAllSelectedNamesOnCanvas(elementId);

                playerNames.filter(n => n !== "선택")
                    .sort((a, b) => a.localeCompare(b))
                    .forEach(playerName => {
                        // 현재 드롭다운의 이름이 아닌 경우, 다른 곳에서 사용 중이면 옵션에서 제외
                        if (!selectedNamesOnCanvas.includes(playerName) || playerName === currentName) {
                            selectElement.appendChild(new Option(playerName, playerName));
                        }
                    });
                selectElement.value = currentName; // Set selected value back
            });
        }

        /**
         * 선택된 쿼터에 따라 스쿼드를 불러오거나 기본 전술을 적용하는 통합 함수
         * @param {string} quarter - 불러오거나 적용할 쿼터 (예: "1 쿼터")
         * @param {boolean} applyCurrentFormation - true이면 현재 선택된 전술을 적용, false이면 저장된 스쿼드를 로드 (기본값)
         */
        function loadOrApplySquad(quarter, applyCurrentFormation = false) {
            drawBackground();

            let newPlayersList = []; // 현재 쿼터의 필드 플레이어 목록 (심판/촬영 제외)
            let currentQuarterRefereeName = '선택'; // 현재 쿼터에 적용될 심판 이름
            let currentQuarterFilmingName = '선택'; // 현재 쿼터에 적용될 촬영 이름

            if (applyCurrentFormation) { // 전술 드롭다운 변경 시
                newPlayersList = getFormationPlayers(formationSelect.value);
                // 심판/촬영 이름은 현재 드롭다운에 선택된 상태를 유지
                currentQuarterRefereeName = refereeSelect.value;
                currentQuarterFilmingName = filmingSelect.value;
                console.log(`새 전술 '${formationSelect.value}'를 현재 쿼터 '${quarter}'에 적용합니다.`);

            } else if (savedSquads[quarter]) { // 쿼터 드롭다운 변경 또는 초기 로드 시 저장된 스쿼드가 있다면
                const loadedSquad = JSON.parse(JSON.stringify(savedSquads[quarter]));
                newPlayersList = loadedSquad.filter(p => p.position !== '심판' && p.position !== '촬영');

                // 저장된 스쿼드에서 심판 및 촬영 이름 불러오기
                const loadedReferee = loadedSquad.find(p => p.position === '심판');
                const loadedFilming = loadedSquad.find(p => p.position === '촬영');
                currentQuarterRefereeName = loadedReferee ? loadedReferee.name : '선택';
                currentQuarterFilmingName = loadedFilming ? loadedFilming.name : '선택';

                // 저장된 고정 인원 박스 위치도 업데이트
                const savedFixedBoxData = loadedSquad.find(p => p.id === 'fixedBox');
                if (savedFixedBoxData) {
                    fixedPersonnelData.x = savedFixedBoxData.x;
                    fixedPersonnelData.y = savedFixedBoxData.y;
                }

                console.log(`'${quarter}' 스쿼드를 불러왔습니다.`);
            } else { // 저장된 스쿼드가 없고, 전술 변경이 아닌 경우 (기본 초기화)
                newPlayersList = getFormationPlayers(formationSelect.value);
                // 심판/촬영 이름은 기본값 '선택' 유지
                currentQuarterRefereeName = '선택';
                currentQuarterFilmingName = '선택';
                // 고정 박스 위치도 초기 위치로 리셋 (혹은 마지막으로 드래그된 위치를 유지할 수도 있음)
                const originalCanvasWidth = 1200;
                const originalCanvasHeight = 750;
                fixedPersonnelData.x = originalCanvasWidth * 0.85;
                fixedPersonnelData.y = originalCanvasHeight * 0.1;
                console.log(`'${quarter}'에 저장된 스쿼드가 없어 기본 전술을 적용합니다.`);
            }

            players = newPlayersList; // 전역 players 배열 업데이트 (필드 플레이어만 포함)

            // 드롭다운의 실제 값 업데이트 및 옵션 채우기 (중복 방지 로직 적용)
            refereeSelect.value = currentQuarterRefereeName;
            filmingSelect.value = currentQuarterFilmingName;
            populateFixedPersonnelSelects(); // 심판, 촬영 드롭다운 먼저
            renderPlayers(); // 필드 플레이어 드롭다운 (이 함수 내에서 createPlayerInput 호출)

            updateSquadSummaryTable(); // 요약 테이블 업데이트
            setCanvasDimensions(); // 고정 박스 위치 업데이트를 위해 다시 호출
        }


        /**
         * 스쿼드 요약 테이블을 선수별 쿼터 포함 정보를 포함하여 업데이트하는 함수
         */
        function updateSquadSummaryTable() {
            // 기존 테이블 본문 지우기
            squadSummaryBody.innerHTML = '';

            const playerSummaryData = [];
            // 모든 선수 명단을 기반으로 요약 데이터 초기화
            playerNames.forEach(name => {
                // '선택' 옵션은 요약 테이블에서 제외
                if (name !== "선택") {
                    const quartersIncluded = [];
                    for (const quarter in savedSquads) {
                        const squad = savedSquads[quarter];
                        // 스쿼드에 포함된 플레이어 중 심판/촬영 포지션이 아닌 플레이어만 카운트
                        if (squad.some(p => p.name === name && p.position !== '심판' && p.position !== '촬영')) {
                            quartersIncluded.push(quarter);
                        }
                    }

                    // 심판이나 촬영 인원에게 할당된 이름인지 확인
                    const isRefereeName = (name === refereeSelect.value);
                    const isFilmingName = (name === filmingSelect.value);

                    // 이름이 심판이나 촬영 인원에게 할당되었고, '선택'이 아니라면 쿼터 정보 없이 추가
                    if ((isRefereeName || isFilmingName) && name !== "선택") {
                        playerSummaryData.push({ name: name, quarters: [], quarterCount: 0 }); // 쿼터 정보 없음
                    } else {
                        // 일반 플레이어는 쿼터 정보를 포함하여 추가
                        playerSummaryData.push({ name: name, quarters: quartersIncluded.sort(), quarterCount: quartersIncluded.length });
                    }
                }
            });

            // 현재 정렬 기준과 방향에 따라 데이터 정렬
            playerSummaryData.sort((a, b) => {
                let comparison = 0;
                if (currentSortColumn === 'name') {
                    comparison = a.name.localeCompare(b.name);
                } else if (currentSortColumn === 'quarters') {
                    // 쿼터 이름 문자열로 정렬 (쿼터 수가 아닌 문자열 자체)
                    comparison = a.quarters.join(', ').localeCompare(b.quarters.join(', '));
                } else if (currentSortColumn === 'quarterCount') {
                    comparison = a.quarterCount - b.quarterCount;
                }
                return currentSortDirection === 'asc' ? comparison : -comparison;
            });

            // 테이블 본문에 데이터 채우기
            playerSummaryData.forEach(player => {
                const row = squadSummaryBody.insertRow();
                const cellName = row.insertCell();
                const cellQuarters = row.insertCell();
                const cellQuarterCount = row.insertCell(); // 새로운 셀 추가
                const cellAction = row.insertCell(); // 작업 셀 추가

                cellName.textContent = player.name;
                cellQuarters.textContent = player.quarters.join(', '); // 쉼표로 구분하여 표시
                cellQuarterCount.textContent = player.quarterCount; // 쿼터 수 표시

                // 삭제 버튼 추가
                const deleteButton = document.createElement('button');
                deleteButton.textContent = '삭제';
                deleteButton.className = 'delete-button';
                deleteButton.onclick = () => deletePlayerFromRoster(player.name);
                cellAction.appendChild(deleteButton);
            });
        }

        /**
         * 선수 명단에서 선수를 삭제하는 함수
         * @param {string} playerName - 삭제할 선수 이름
         */
        function deletePlayerFromRoster(playerName) {
            // playerNames 배열에서 이름 제거
            const nameIndex = playerNames.indexOf(playerName);
            if (nameIndex > -1) {
                playerNames.splice(nameIndex, 1);
            }

            // 현재 캔버스에 있는 선수들 중 해당 이름을 가진 선수를 "선택"으로 변경
            players.forEach(p => {
                if (p.name === playerName) {
                    p.name = "선택";
                }
            });

            // 저장된 모든 스쿼드에서 해당 이름을 가진 선수를 "선택"으로 변경
            for (const quarter in savedSquads) {
                savedSquads[quarter].forEach(p => {
                    if (p.name === playerName) {
                        p.name = "선택";
                    }
                });
            }

            // 심판/촬영 드롭다운에서 해당 이름이 선택되어 있다면 "선택"으로 변경
            if (refereeSelect.value === playerName) {
                refereeSelect.value = "선택";
            }
            if (filmingSelect.value === playerName) {
                filmingSelect.value = "선택";
            }

            // UI 전체 갱신
            populateFixedPersonnelSelects(); // 고정 인원 드롭다운 갱신
            renderPlayers(); // 필드 플레이어 드롭다운 갱신
            updateSquadSummaryTable(); // 요약 테이블 갱신
            console.log(`${playerName} 선수가 명단에서 삭제되었습니다.`);
        }


        // 이벤트 리스너: 전술 선택 변경 시
        formationSelect.addEventListener('change', (e) => {
            // 전술 변경 시에는 applyCurrentFormation을 true로 전달하여 현재 전술을 적용하도록 함
            loadOrApplySquad(quarterSelect.value, true);
        });

        // 이벤트 리스너: 쿼터 선택 변경 시 배경 다시 그리기 및 스쿼드 불러오기
        quarterSelect.addEventListener('change', (e) => {
            // 쿼터 변경 시에는 applyCurrentFormation을 false로 전달하여 저장된 스쿼드를 로드하도록 함
            loadOrApplySquad(e.target.value, false);
        });

        // 이벤트 리스너: 선수 명단에 선수 추가 (새로운 선수 이름을 목록에 추가)
        addPlayerToRosterButton.addEventListener('click', () => {
            const inputNames = newPlayerNameInput.value.trim();
            if (inputNames) {
                // 쉼표 또는 공백으로 분리하고 각 이름에서 공백 제거
                const namesToAdd = inputNames.split(/[, ]+/).map(name => name.trim()).filter(name => name !== '');
                let playersAdded = 0;
                let ignoredNames = [];

                namesToAdd.forEach(newName => {
                    // '선택', '심판', '촬영'과 같은 특별한 이름은 명단에 추가하지 않음
                    if (!playerNames.includes(newName) && newName !== '선택' && newName !== '심판' && newName !== '촬영') {
                        playerNames.push(newName);
                        playersAdded++;
                    } else {
                        ignoredNames.push(newName);
                    }
                });

                // playerNames 배열 정렬 ("선택" 제외)
                const selectedOptionIndex = playerNames.indexOf("선택");
                let tempPlayerNames = [];
                if (selectedOptionIndex !== -1) {
                    tempPlayerNames = playerNames.splice(selectedOptionIndex, 1); // "선택"을 일시적으로 제거
                }
                playerNames.sort((a, b) => a.localeCompare(b)); // 나머지 정렬
                if (tempPlayerNames.length > 0) {
                    playerNames.unshift(tempPlayerNames[0]); // "선택"을 다시 맨 앞에 추가
                }

                newPlayerNameInput.value = ''; // 입력 필드 초기화

                // 사용자에게 추가 결과 피드백
                if (playersAdded > 0) {
                    console.log(`${playersAdded}명의 선수가 명단에 추가되었습니다.`);
                }
                if (ignoredNames.length > 0) {
                    console.log(`이미 명단에 있는 선수: ${ignoredNames.join(', ')} (추가되지 않음)`);
                }
                if (playersAdded === 0 && ignoredNames.length === 0) {
                    console.log("추가할 유효한 선수 이름이 없습니다.");
                }

                populateFixedPersonnelSelects(); // 명단 변경 후 고정 인원 드롭다운 갱신
                renderPlayers(); // 명단 변경 후 필드 플레이어 드롭다운 갱신
                updateSquadSummaryTable(); // 명단 변경 후 요약 테이블 업데이트
            } else {
                console.log("선수 이름을 입력해주세요.");
            }
        });

        // 이벤트 리스너: "스쿼드 저장" 버튼
        saveSquadButton.addEventListener('click', () => {
            const currentQuarter = quarterSelect.value;
            // 현재 플레이어 목록에 심판과 촬영 인원 정보를 추가하여 저장
            const squadToSave = JSON.parse(JSON.stringify(players));
            squadToSave.push({ position: '심판', name: refereeSelect.value, id: 'refereeSelect' }); // ID 추가
            squadToSave.push({ position: '촬영', name: filmingSelect.value, id: 'filmingSelect' }); // ID 추가
            squadToSave.push({ id: fixedPersonnelData.id, x: fixedPersonnelData.x, y: fixedPersonnelData.y, position: 'FixedBox' }); // 고정 박스 위치 저장

            savedSquads[currentQuarter] = squadToSave;
            console.log(`'${currentQuarter}' 스쿼드가 저장되었습니다.`);
            updateSquadSummaryTable(); // 스쿼드 저장 후 요약 테이블 업데이트
            // 필요에 따라 사용자에게 시각적 피드백 제공 (예: 임시 성공 메시지)
        });

        // 테이블 헤더 클릭 이벤트 리스너 (정렬용)
        squadSummaryTable.querySelectorAll('th').forEach(header => {
            header.addEventListener('click', () => {
                const sortKey = header.dataset.sortKey;
                if (sortKey) {
                    if (currentSortColumn === sortKey) {
                        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSortColumn = sortKey;
                        currentSortDirection = 'asc'; // 새 열에 대해서는 기본적으로 오름차순 정렬
                    }
                    updateSquadSummaryTable(); // 새 정렬 기준으로 테이블 다시 렌더링
                }
            });
        });

        // 드래그 로직 (플레이어 박스 및 고정 박스)
        document.addEventListener('mousemove', (e) => {
            if (selectedPlayer && selectedPlayer.id === 'fixedBox') {
                const containerRect = canvasContainer.getBoundingClientRect();
                const element = selectedPlayer.element;

                const originalCanvasWidth = 1200;
                const originalCanvasHeight = 750;

                const currentScaleX = containerRect.width / originalCanvasWidth;
                const currentScaleY = containerRect.height / originalCanvasHeight;

                let newX = e.clientX - containerRect.left - offsetX;
                let newY = e.clientY - containerRect.top - offsetY;

                newX = Math.max(0, Math.min(newX, containerRect.width - element.offsetWidth));
                newY = Math.max(0, Math.min(newY, containerRect.height - element.offsetHeight));

                element.style.left = `${newX}px`;
                element.style.top = `${newY}px`;

                // Update fixedPersonnelData's x and y based on current scaled position
                fixedPersonnelData.x = (newX + element.offsetWidth / 2) / currentScaleX;
                fixedPersonnelData.y = (newY + element.offsetHeight / 2) / currentScaleY;

            } else if (selectedPlayer && selectedPlayer.inputElement) { // 일반 플레이어 드래그 로직
                 const containerRect = canvasContainer.getBoundingClientRect();
                const playerElement = selectedPlayer.inputElement;

                const originalCanvasWidth = 1200;
                const originalCanvasHeight = 750;

                const currentScaleX = containerRect.width / originalCanvasWidth;
                const currentScaleY = containerRect.height / originalCanvasHeight;

                let newX = e.clientX - containerRect.left - offsetX;
                let newY = e.clientY - containerRect.top - offsetY;

                newX = Math.max(0, Math.min(newX, containerRect.width - playerElement.offsetWidth));
                newY = Math.max(0, Math.min(newY, containerRect.height - playerElement.offsetHeight));

                playerElement.style.left = `${newX}px`;
                playerElement.style.top = `${newY}px`;

                selectedPlayer.x = (newX + playerElement.offsetWidth / 2) / currentScaleX;
                selectedPlayer.y = (newY + playerElement.offsetHeight / 2) / currentScaleY;
            }
        });

        document.addEventListener('mouseup', () => {
            if (selectedPlayer) {
                if (selectedPlayer.id === 'fixedBox') {
                    selectedPlayer.element.style.cursor = 'grab';
                } else {
                    selectedPlayer.inputElement.style.cursor = 'grab'; // 커서 원래대로
                }
            }
            selectedPlayer = null;
        });

        // 고정 인원 박스 자체에 드래그 이벤트 리스너 추가
        fixedPersonnelBox.addEventListener('mousedown', (e) => {
            // 드롭다운 클릭 시에는 드래그 방지
            if (e.target.tagName === 'SELECT') {
                return;
            }
            selectedPlayer = fixedPersonnelData; // selectedPlayer를 fixedPersonnelData 객체로 설정
            offsetX = e.clientX - fixedPersonnelBox.getBoundingClientRect().left;
            offsetY = e.clientY - fixedPersonnelBox.getBoundingClientRect().top;
            fixedPersonnelBox.style.cursor = 'grabbing';
            e.preventDefault();
        });


        // 심판/촬영 드롭다운 변경 시 UI 업데이트
        refereeSelect.addEventListener('change', populateFixedPersonnelSelects);
        refereeSelect.addEventListener('change', renderPlayers);
        refereeSelect.addEventListener('change', updateSquadSummaryTable);

        filmingSelect.addEventListener('change', populateFixedPersonnelSelects);
        filmingSelect.addEventListener('change', renderPlayers);
        filmingSelect.addEventListener('change', updateSquadSummaryTable);

        // 창 크기 변경 시
        window.addEventListener('resize', () => {
            drawBackground();
            renderPlayers(); // 필드 플레이어만 재렌더링하여 위치 업데이트
            // 고정 인원 박스의 위치 재설정
            setCanvasDimensions();
            populateFixedPersonnelSelects(); // 드롭다운 옵션도 갱신
            updateSquadSummaryTable();
        });

        // PNG 다운로드 버튼 클릭 시
        downloadButton.addEventListener('click', () => {
            html2canvas(canvasContainer, {
                useCORS: true,
                scale: 2
            }).then(canvas => {
                const link = document.createElement('a');
                const fileName = `${quarterSelect.value.replace(/\s/g, '-')}.png`;
                link.download = fileName;
                link.href = canvas.toDataURL('image/png');
                link.click();
            }).catch(error => {
                console.error("캔버스 캡처 중 오류 발생:", error);
            });
        });


        // 초기 앱 로드 시 실행되는 함수들
        setCanvasDimensions(); // 캔버스 크기 먼저 설정

        // loadOrApplySquad 함수가 모든 초기화 및 로딩을 처리
        loadOrApplySquad(quarterSelect.value);
    </script>
</body>
</html>
